#' B-spline basis function
b_spline <- function(x, knots, degree, i) {
# Base case: 0th degree
if (degree == 0) {
return(ifelse(knots[i] <= x & x < knots[i + 1], 1, 0))
}
# Recursive case: degree > 0
B_i_d1 <- b_spline(x, knots, degree - 1, i)
B_i1_d1 <- b_spline(x, knots, degree - 1, i + 1)
denom1 <- knots[i + degree] - knots[i]
denom2 <- knots[i + degree + 1] - knots[i + 1]
term1 <- if (denom1 == 0) 0 else ((x - knots[i]) / denom1)*B_i_d1
term2 <- if (denom2 == 0) 0 else ((knots[i + degree + 1] - x) / denom2)*B_i1_d1
return(term1 + term2)
}
#' Create design matrix of B-spline basis
create_design_matrix <- function(x_values, knots, degree){
n <- length(x_values) # number of the data
num_basis <- length(knots) - degree - 1 # number of the basis function
design_matrix <- matrix(0, nrow = n, ncol = num_basis)
for (j in 1:num_basis){
for (i in 1:n){
design_matrix[i, j] <- b_spline(x_values[i], knots, degree, j)
}
}
return(design_matrix)
}
#' Fitting P-spline model
#'
#' This function computes the coefficients P-spline estimator.
#'
#' @param x_values Numeric vector of x (input)
#' @param y_values Numeric vector of y (response)
#' @param interior_knots Vector of interior knots
#' @param degree Degree of the B-spline basis (default = 3)
#' @param lambda Smoothing parameter (default = 1e-2)
#' @param diff_order Order of the difference penalty (default = 2)
#'
#' @return List contains the spline coefficients, knots, degree, lambda, penalty matrix.
#'
#' @examples
#' set.seed(924)
#' n= 100
#' x_values= sort(runif(n, 0, 1))
#' y_values= sin(2*pi*x_values) + cos(4*pi*x_values) + rnorm(n, sd= 0.2)
#' # spline degree specification
#' degree= 3
#' # knot generation
#' num_interior= 5
#' interior_knots= knots_quantile(x_values, num_interior)
#' # setting the value of lambda and the difference penalty order
#' lambda= 1e-2
#' diff_order= 2
#' # model fitting
#' model= fit_pspline(x_values, y_values, interior_knots, degree, lambda, diff_order)
#' print(model)
#'
#'
#' @export
fit_pspline <- function(x_values, y_values, interior_knots,
degree = 3, lambda = 1e-2, diff_order = 2){
# 1. Set the whole knots
knots <- add_boundary_knots(x_values, interior_knots, degree)
# 2. Compute the design matrix of B-spline
G <- create_design_matrix(x_values, knots, degree)
# 3. 차분 행렬 D 생성
num_basis <- ncol(G)
D <- diff(diag(num_basis), differences = diff_order)
# 4. Compute the penalty matrix (P = D^T D)
P <- t(D) %*% D
# 5. Penalized Least Squares
beta_hat <- solve(t(G) %*% G + lambda * P) %*% t(G) %*% y_values
return(list(beta = beta_hat, knots = knots, degree = degree,
lambda = lambda, penalty = P))
}
#' The function of interior knots sequence
#'
#' This function computes a knot sequence using the quantiles of the data.
#'
#' @param x Numeric vector of the data
#' @param dimension Number of the basis functions
#' @param degree Degree of spline (default= 3)
#'
#' @return Numeric vector with interior knots sequence
#' @export
#'
#' @examples
#' set.seed(924)
#' x = runif(100, 0, 1)
#' knots = knots_quantile(x, 5, 3)
#' print(knots)
knots_quantile<- function(x, dimension, degree = 3) {
dimension = max(dimension, degree + 1)
num_interior = dimension - degree - 1
if (num_interior > 0) {
probs<- (1:num_interior)/(num_interior+1)
interior_knots<- quantile(x, probs, type= 1)
} else {
interior_knots<- numeric(0)
}
return(interior_knots)
}
#' Add boundary knots to interior knots.
add_boundary_knots <- function(x, interior_knots, degree = 3, tiny = 1e-5) {
knots<- c(rep(min(x) - tiny, degree + 1), interior_knots, rep(max(x) + tiny, degree + 1))
return(knots)
}
#' Plotting P-spline with scatter plots
#'
#' This function provides a plot of the P-spline.
#'
#' @param x_values,y_values Numeric vector
#' @param model Function that fit P-spline with given data points
#' @param grid_x Numeric vector with a grid of evaluation points
#'
#' @export
#' @import ggplot2
plot_pspline = function(x_values, y_values, model, grid_x)
{
y_pred = predict_pspline(model, grid_x)
data_plot = data.frame(x = x_values, y = y_values)
spline_plot = data.frame(x = grid_x, y = y_pred)
ggplot() +
geom_point(data = data_plot, aes(x, y), color = "blue") +
geom_line(data = spline_plot, aes(x, y), color = "red", linewidth = 1.2) +
labs(title = "Fitted P-spline Regression", x = "x", y = "y") +
xlim(c(min(x_values), max(x_values)))
}
#' Predicting the values of y for given x based on P-spline
#'
#' This function computes the predicted values of y for given x based on P-spline.
#'
#' @param model Function that fit P-spline with given data points
#'
#' @param new_x Numeric vector expressing a grid of evaluation points
#'
#' @return Numeric vector with predicted values at new_x
#'
#' @export
predict_pspline = function(model, new_x){
G_new = create_design_matrix(new_x, model$knots, model$degree)
y_pred = G_new %*% model$beta
return(y_pred)
}
usethis::create_package('.')
library(devtools)
devtools::document()
